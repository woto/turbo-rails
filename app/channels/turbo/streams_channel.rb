# The streams channel delivers all the turbo-stream actions created (primarily) through <tt>Turbo::Broadcastable</tt>.
# A subscription to this channel is made for each individual stream that one wishes to listen for updates to.
# The subscription relies on being passed a <tt>signed_stream_name</tt> parameter generated by turning a set of streamables
# into signed stream name using <tt>Turbo::Streams::StreamName#signed_stream_name</tt>. This is automatically done
# using the view helper <tt>Turbo::StreamsHelper#turbo_stream_from(*streamables)</tt>.
# If the signed stream name cannot be verified, the subscription is rejected.
#
# It's important to understand that while stream names are signed, <tt>Turbo::StreamsChannel</tt> doesn't authenticate connections or
# authorize subscriptions. You can configure <tt>Turbo::StreamsChannel</tt> to use e.g your <tt>ApplicationCable::Channel</tt> to
# implement authorization in your config/application.rb:
#
# config.turbo.base_stream_channel_class = "ApplicationCable::Channel"
#
# You can also choose which channel to use via:
# <%= turbo_stream_from "room", channel: CustomChannel %>
#
# Note that any channel that listens to a <tt>Turbo::Broadcastable</tt> compatible stream name
# (e.g <tt>verified_stream_name_from_params</tt>) can also be subscribed to via <tt>Turbo::StreamsChannel</tt>. Meaning that you should
# never use the <tt>turbo_stream_from</tt> <tt>:channel</tt> option to implement authorization.
class Turbo::StreamsChannel < Turbo.base_stream_channel_class.constantize
  extend Turbo::Streams::Broadcasts, Turbo::Streams::StreamName
  include Turbo::Streams::StreamName::ClassMethods

  def subscribed
    if subscription_allowed?
      stream_from stream_name
    else
      reject
    end
  end

  private
    def subscription_allowed?
      stream_name && authorized?
    end

    def stream_name
      @stream_name ||= verified_stream_name_from_params
    end

    # Override this method to match your authorization rules in <tt>Turbo.base_stream_channel_class</tt> e.g:
    # <tt>current_user.can_access? streamable</tt>. <tt>current_user<tt> should match your
    # <tt>ApplicationCable::Connection</tt> <tt>identified_by</tt>.
    def authorized?
      defined?(super) ? super : true
    end

    # Helpful for implementing domain specific authorization rules when overriding <tt>authorized?</tt>.
    def streamable
      @streamable ||= GlobalID::Locator.locate(stream_name)
    end
end
